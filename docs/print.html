<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Little Book of Computational Biology</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="DNA.html"><strong aria-hidden="true">1.</strong> DNA</a></li><li class="chapter-item expanded "><a href="cells.html"><strong aria-hidden="true">2.</strong> Protein and Cells</a></li><li class="chapter-item expanded "><a href="transcription-networks.html"><strong aria-hidden="true">3.</strong> Transcription Networks</a></li><li class="chapter-item expanded "><a href="sequence-matching.html"><strong aria-hidden="true">4.</strong> Sequence Matching</a></li><li class="chapter-item expanded "><a href="hmm.html"><strong aria-hidden="true">5.</strong> Hidden Markov Models</a></li><li class="chapter-item expanded "><a href="neural.html"><strong aria-hidden="true">6.</strong> Neural Applications</a></li><li class="chapter-item expanded "><a href="population-dynamics.html"><strong aria-hidden="true">7.</strong> Population Dynamics</a></li><li class="chapter-item expanded "><a href="evo-trees.html"><strong aria-hidden="true">8.</strong> Evolutionary Trees</a></li><li class="chapter-item expanded "><a href="boolean-networks.html"><strong aria-hidden="true">9.</strong> Boolean Networks</a></li><li class="chapter-item expanded "><a href="epigenetics.html"><strong aria-hidden="true">10.</strong> Epigenetics</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Little Book of Computational Biology</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/jackdarlison/the-little-book-of-computational-biology" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Understanding biology is a big data problem. </p>
<p>Large datasets have been created to understand biological systems</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dna"><a class="header" href="#dna">DNA</a></h1>
<h3 id="biology"><a class="header" href="#biology">Biology</a></h3>
<p>DNA is a helix of antiparallel chains of nucleic acids, bonded via adenine (A) + thymine (T) or guanine (G) + cytosine (C) bonds</p>
<p>The human genome consists of 64 billion pairs. The majority of which resides in the nucleus of each cell, however, small amounts reside in the mitochondria. </p>
<p>Sequences of DNA which have functional purposes are known as genes.</p>
<p>DNA creates structures called chromosomes, which are held together by histones (a protein). Humans have 23 pairs of chromosomes which reside in the nucleus of each cell. 22 of these are known as autosomes, numbered in decreasing size, and the 23rd are the sex chromosomes (Female is XX, male is XY)</p>
<p>DNA replication follows the process of:</p>
<ul>
<li>Helicase enzyme splits the two strands</li>
<li>DNA polymerase (enzyme) and free nucleotides combine of the two strands</li>
</ul>
<p>Mutations are alterations of the nucleotide sequence in the genome of an organism, caused by:</p>
<ul>
<li>DNA copying mistakes</li>
<li>Environmental mutagens (e.g. radiation)</li>
<li>Infection by retroviruses</li>
</ul>
<p>Mutations consist of three types:</p>
<ul>
<li>Point mutations</li>
<li>Frameshift (insertion or delations)</li>
<li>chromosomal exchanges/alterations</li>
</ul>
<p>Transposons are genes which can change position (usually during replication) in the genome. These can create or reverse mutations. </p>
<p>Mutations can be hereditary (germline mutations) or occur during life (somatic mutations). Mutations can have negative, none, or positive benefits. </p>
<p>RNA is a single strand of nucleic acid, the Thymine (T) base in DNA is replaced with Uracil (U) in RNA. RNA strands can associate (match) with single strands of DNA</p>
<p>There are three types of RNA:</p>
<ul>
<li>Messenger RNA, synthesised from DNA in nucleus and delivered to Ribosomes,  <strong>Transcription</strong></li>
<li>Ribosomal RNA, forms Ribosomes along with proteins</li>
<li>Transfer RNA, used to create proteins, <strong>Translation</strong></li>
</ul>
<p><strong>Transcription</strong> is the process of creating mRNA from DNA. The enzyme RNA polymerase unwinds the DNA into single strands, synthesises a strand of mRNA from one of the DNA strands, and finally recombines the DNA.</p>
<p>mRNA is transported to the ribosomes to undergo <strong>Translation</strong> which involves synthesising proteins based upon the template of the mRNA. tRNA consists of three nucleotide bases and are connected to an amino acid. The three bases in tRNA then match with sequences in the mRNA, thus the amino acids create a chain based on the sequence of mRNA. This is chain is later folded to create a specific protein.</p>
<p>The mRNA is <strong>spliced</strong> before translation. mRNA consists of two regions, the introns and exons. The introns are removed during the splicing process and exons combined, yielding sections of the mRNA called the <em>open reading frame</em> which are using in translation, there are untranslated regions either side of the open reading frames. </p>
<p><strong>Codons</strong> are the sequence of three nucleic bases that correspond to a specific amino acid. There are specific start (AUG) and stop (UAA, UAG, UGA) codons that indicate when to start and end translation for a specific protein. Codon tables map between  mRNA (<em>not tRNA</em>) and amino acids </p>
<p><strong>Genes</strong> are sequences of nucleotides which synthesise a specific gene product, i.e. a protein or RNA molecule. </p>
<p>Only 2% of the genome are protein encoding exons</p>
<h3 id="sequencing"><a class="header" href="#sequencing">Sequencing</a></h3>
<p>The Humane Genome Project aims to sequence the entire genome, it is mostly finished. </p>
<p>Sequencing the entire genome in one go is impossible, so smaller sequences are used and combined together on overlaps</p>
<p>DNA is sequenced by:</p>
<ul>
<li>separating the chromosomes</li>
<li>Isolating the DNA</li>
<li>fragmenting into manageable chunks using enzymes</li>
<li>Inserted into bacteria, which replicates the DNA (Bacterial Artificial Chromosomes, BACS) so there is sufficient concentrations to run the sequencing on. </li>
<li>Copied DNA is sequenced and assembled into a physical map</li>
<li>Gene locations are assessed, and genetic map produced</li>
</ul>
<p>Three methods of sequencing:</p>
<ul>
<li>PacBio HiFi: 10-25kb with accuracy &gt;99.5%
<ul>
<li>Florescence based</li>
</ul>
</li>
<li>Illumina: 0.25kb with accuracy &gt;99.9%
<ul>
<li>Florescence based</li>
</ul>
</li>
<li>Oxford Nanopore: 1500kb with 87-98% accuracy
<ul>
<li>Electric current based</li>
</ul>
</li>
</ul>
<p>Reassembling sequences can be challenging as there may be ambiguities when aligning different sequences. Long repeats are especially ambiguous</p>
<h3 id="tries"><a class="header" href="#tries">Tries</a></h3>
<p>A Trie, or digital tree, is often used to store sets of words. In DNAs case there are only 4 letters. Each node is a letter, which branches to the next letter in the sequences. All sequences end with the $ character. </p>
<p>Branches are usually collapsed if there is only one path. </p>
<p>Tries provide a implementation for a set of words which has quick insertion, deletion and find. Making them useful for algorithms used for spell checking, completion, prefix and suffix matching.</p>
<p>With DNA they can be used to correct mis-reads by using known sequences tries and finding a good match. DNA uses a 5 way trie, 4 for the bases and 1 for end of sequence markers</p>
<p>There are many fixed and common sequences which can be used to match and check reads with, such as protein binding (promotor regions), stop and start codons, TATA box, ... Some areas of genes have much higher concentrations of certain bases, making them useful for finding areas of genes.</p>
<p>Tries can be quite memory intensive, Suffix trees can be built to use O(n) memory where n is the length of the text and be constructed in O(n) time</p>
<p>Suffix tries are useful for:</p>
<ul>
<li>Applications with multiple searches</li>
<li>exact words matching is important.</li>
<li>useful when looking for repeats</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proteins-and-cells"><a class="header" href="#proteins-and-cells">Proteins and Cells</a></h1>
<p>The human body is made of ~\( 3 \times 10^{13} \) consisting of roughly 200 cell types. 90% of the cells are red blood cells so do not contain DNA. The rest contain DNA in the nucleus, with some in the mitochondria (~37 Genes) </p>
<p>Mitosis is the process of cell replication. In which DNA is replicated, the cell is split, and two identical daughter cells are created from the original. The total number of chromosomes is maintained.</p>
<p>Meiosis is the process of creating gametes (e.g. sperm and egg) from a cell. Gametes are haploid meaning there is only one copy of each chromosome, instead of the usual pairs. Meiosis follows a process of replicating DNA, recombining the chromosomes, splitting into 4 gametes </p>
<h3 id="proteins"><a class="header" href="#proteins">Proteins</a></h3>
<p>All cells in the body have a function, often the vehicle for synthesising proteins. Proteins can be:</p>
<ul>
<li>Enzymes</li>
<li>Messengers (hormones...)</li>
<li>Structural</li>
<li>Transport</li>
<li>Storage</li>
</ul>
<p>Proteins get there functions via their various properties:</p>
<ul>
<li>folding shape</li>
<li>size</li>
<li>polarity</li>
<li>pH</li>
<li>hydro properties</li>
</ul>
<p>Protein folding occurs in the <em>Endoplasmic Reticulum</em>, in addition the Golgi apparatus plays a role in the quality control and recycling, which is needed when they mis-fold.</p>
<p>The cell cycle can be measured by concentrations of proteins in the cell. The time taken to build molecules, transcription, and translation is insignificant to the time taken for protein concentration to change, so we can assume they happen instantaneously</p>
<p>Protein structure can be split into four categories:</p>
<ul>
<li>Primary: The sequence of amino acids</li>
<li>Secondary: Alpha helices, Beta sheets, or coils</li>
<li>Tertiary: 3D structure</li>
<li>Quaternary: protein complex</li>
</ul>
<h4 id="stem-cells"><a class="header" href="#stem-cells">Stem Cells</a></h4>
<p>Mammalian cells are diploid, i.e. they have two sets of chromosomes, which means they have two very slightly different copies of the genome. One of these copies comes from the mother and one from the father. A mammals start as a single cell called a Zygote.</p>
<p>This cell replicates until reaching the foetus stage, where the cells specialise into various functions.</p>
<p>Stem cells are clones which differentiate into more specialised cells given certain growth factors. The expressions of the genes within the cells respond to environmental cues, causing them to differentiate. </p>
<p>Understanding how stem cells specialise is key to understanding human development</p>
<p>To do this, gene regulation networks are created for stem cell differentiation, i.e. a transcription network. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transcription-networks"><a class="header" href="#transcription-networks">Transcription Networks</a></h1>
<p>Genes are controlled by transcriptions factors which excite or inhibit transcription within a gene. </p>
<p>Transcription factors are made of proteins, thus, genes create a network of signals which can respond to stimuli such as glucose requirements and DNA repair, maintaining the balance of a cell</p>
<p>The set of interactions between genes is known as a transcription network, which are responsible for the fine grained control of a cell. Nodes are genes and arcs represent transcription regulation factors</p>
<p>Transcription networks tell us:</p>
<ul>
<li>The genes involved in regulation</li>
<li>The environmental signals (input)</li>
<li>The dynamic system present in the cell</li>
<li>The production rate of proteins</li>
</ul>
<p>We need to understand how rates and concentrations of molecules change to understand the kinetics of enzyme reactions, e.g. transcription factors</p>
<p>Transcription factors fall under two categories:</p>
<ul>
<li>Repressors: binds to promoter region to turn off gene by preventing production of mRNA</li>
<li>Activator: Binds to promoter region to promote production of mRNA
Both of these can bind at the same time</li>
</ul>
<p>These two factors control the transcription rate of a gene. Arcs are indicated with + (Activator) and - (Repressor) and a number to indicate their input function (e.g. the hill coefficient)</p>
<p>With some understanding of the transcription parameters it is possible to simulate the dynamic processes represented in transcription networks, important for understanding how cells respond to environmental factors. </p>
<p>In reality cell molecules are present in very low concentrations and randomness makes creating a function system problematic</p>
<p>Randomness comes from:</p>
<ul>
<li>Extrinsic noise (variations in reaction): difference in number of RNA polymerase, number of ribosomes, size of cell</li>
<li>Intrinsic noise (inherent randomness)</li>
</ul>
<h3 id="chemistry"><a class="header" href="#chemistry">Chemistry</a></h3>
<p>The concentration of chemicals is given as moles </p>
<p>The rate of a reaction for equation: \( X + 2Y \overset{\rightarrow}{k} Z \) is given as \( \frac{d[Z]}{dt} = k[X][Y]^2 \) </p>
<p>The Michalis Menton kinetics is a simple form of enzyme kinetics, in which enzymes and substrates react to create enzymes and a product. The Michalis Menton equation describes the rate of product formulation based on certain assumptions. </p>
<p>To derive the Michalis Menton equation we start with the equation: \[ E + S \underset{k_{-1}}{\overset{k_{1}}{\rightleftarrows}} ES \underset{k_{-2}}{\overset{k_{2}}{\rightleftarrows}} E + P \]
Where:</p>
<ul>
<li>E: Enzyme concentration</li>
<li>S: Substrate concentration</li>
<li>P: Product concentration</li>
<li>k: rate of reactions</li>
</ul>
<p>With the following assumptions:</p>
<ul>
<li>The binding step is fast and E+S to ES starts as equilibrium. This means the product formulation \( k_2 \) is rate limiting</li>
<li>We assume the product starts at zero/little concentration, thus, \( k_{-2} \) can be ignored. The initial rate of product \( V_0 = k_2[ES] \)</li>
<li>\( E_{total} \) can be given as E + ES</li>
<li>The previous assumption is true when S is much larger than E total as the fraction that binds to the enzyme is negligible, meaning S is nearly constant.</li>
</ul>
<p>From the assumptions we get the Rate of formulation equal to the Rate of breakdown, in addition to k-2 == 0. We can write: \[ [E][S] = [ES]K_m;\ K_m = \frac{k_{-1} + k_2}{k_1} \]</p>
<p>Where \( K_m \) is known as the Michaelis Constant</p>
<p>By substituting \( [E] \) for \( [E_{total}] - [ES] \) and rearranging we get: \[ \frac{[E_{total}][S]}{K_m + [S]} = [ES] \]</p>
<p>By plugging into the initial velocity from assumption 2, and assuming that all enzyme will be bound given sufficient substrate (i.e. \(V_{max} = k_2[E_{total}] \)) we get the Michaelis Menton Equation:</p>
<p>\[ V_0 = \frac{V_{max}[S]}{K_m + [S]} \]</p>
<p><img src="Y3/3212/the-little-book-of-computational-biology/src/images/MMplot.png" alt="MM Plot" /></p>
<p>From the plot we can see:</p>
<ul>
<li>Pseudo-linear when substrate concentration is low</li>
<li>Reaches saturation at high substrate</li>
<li>Is half maximal when substrate equals constant</li>
</ul>
<p>So far MM has assumed there is no repressor or activator</p>
<p>We can use the Hill Function to model the presence of repressors and activators. Which consists of:</p>
<ul>
<li>\( K \): the activation coefficient, i.e. the concentration of X required to repress expression</li>
<li>\( $\beta$ \): the maximal production rate </li>
<li>\( n \): the hill coefficient</li>
</ul>
<p>The <strong>Repressor Hill function</strong> is given: \[ f(X) = \beta \frac{K^n}{K^n + X^n} \]</p>
<p><img src="Y3/3212/the-little-book-of-computational-biology/src/images/RHF.png" alt="RHF Plot" /></p>
<p>The <strong>Activator Hill function</strong> is given: \[ f(X) = \beta \frac{X^n}{K^n + X^n} \]</p>
<p><img src="Y3/3212/the-little-book-of-computational-biology/src/images/AHF.png" alt="AHF Plot" /></p>
<p>Where n=1 we have MM dynamics</p>
<p>To model the promotor activity, where:</p>
<ul>
<li>D = promoter</li>
<li>X = repressor</li>
<li>Kd = off/on</li>
</ul>
<p>\[ X + D \underset{k_{on}}{\overset{k_{off}}{\rightleftarrows}} XD \]</p>
<p>The total concentration of the promoter is given: \( [D_T] = [D] + [XD] \)</p>
<p>At equilibrium (\( \frac{d[XD]}{dt} = 0 \)) we get \( \frac{D}{D_T} = \frac{1}{1 + [X]/K_d} \) which can give us the promotor activity when multiplied by \( \beta \)</p>
<p>By adding a repressor protein we get \( X_T = [X] + [XS_X] \), At equilibrium we get \[ \frac{[X_T][S_X]}{K_X + [S]} = [XS_X] \] i.e. the MM equation</p>
<p>However, must transcription factors are comprised of repeated sub units, giving us: \[\frac{[nXS_X]}{[X_T]} = \frac{[S_X]^n}{K^n_X + [S_X]^n} \] at equilibrium i.e. the hill equation</p>
<p>In reality both the repressor and activator can bind to the gene at different points within the promotor. Therefore, we need a multidimensional input of both the activator and repressor concentrations</p>
<h4 id="systems-of-equations"><a class="header" href="#systems-of-equations">Systems of Equations</a></h4>
<p>The reaction rate of \( 2X + Y \overset{k}{\rightarrow} 3X \) is \( \frac{d[X]}{dt} = k[Y][X]^2 \).</p>
<p>To calculate this in number of molecules we need to divide the concentration by \( \Omega \) which is volume times Avogadros number,  giving us: \[ \frac{1}{\Omega}\frac{d[X]}{dt} = k\frac{1}{\Omega^3}[Y][X]^2 \] </p>
<p>We also need to factor in the volume of the reaction area</p>
<p><strong>Gillespie's Algorithm</strong> gives us a method of counting the number of molecules over time given a system of equations. </p>
<p>At each time interval \([t, t + dt] \):</p>
<ul>
<li>We first calculate the <strong>Propensity</strong> of each equation, i.e. the probability of a reaction occurring. This is calculated for each equation though the reaction rate times the product concentration times the volume</li>
<li>We then draw a random time step from an exponential distribution on the total propensity of all the equations</li>
<li>Next, choose an equation to take place with probabilities based on their proportion of the total propensity.</li>
<li>Update the number of molecules based on the equation which took place</li>
</ul>
<p>Gillespies provides the best approximation to the true dynamics within a cell. It is purely numerical so does not provide much insight into how changing the parameters will change the dynamics. </p>
<p>It is often used to check the validity of other models such as ODEs and Monte Carlo</p>
<p>However, computers are not fast enough to truly simulate chemical reactions. Chemical reactions can happen orders of magnitude faster, we may need to approximate or assume a quasi-equilibrium. </p>
<h4 id="creating-a-transcription-network"><a class="header" href="#creating-a-transcription-network">Creating a Transcription Network</a></h4>
<p><em>for stem cell differentiation</em></p>
<p>The first step is establishing the relative concentrations of different mRNA present within the cells at different timepoints. </p>
<p>Correlation does not always imply causation:</p>
<ul>
<li>X could affect Y</li>
<li>Y could affect X</li>
<li>X and Y could be independent, but affected by Z</li>
</ul>
<p>For each mRNA we have a sequence of concentrations over time. From this we can determine if two mRNA molecules are correlated (excitation) or anti-correlated (inhibition)</p>
<p>Pearson correlation is a measure of linear correlation between two sets of data, which measures correlation with cosine similarity. Which can be used to determine if the two mRNA molecules are correlated</p>
<p>From the correlations/relationships we can create a gene regulation network. However we do not know about causation. </p>
<p>Two random variables are statistically independent if P(X, Y) = P(X)P(Y), which implies the variables uncorrelated and have no causality. </p>
<p>However, statistical independence is too powerful. So we use Conditional independence instead, i.e. P(X, Y|Z) = P(X|Z)P(Y|Z). This shows that we can have correlation but no direct causation between the two variables. </p>
<p>It is very difficult to obtain a measure of causational probability, the best we can do is find an explanation of our variables with as few causal interactions as possible. </p>
<p>It is possible to create a <em>Multi-variate Normal Distribution</em> to give a measure of correlation between two points. By finding the covariance  of the two points, and dividing by the square-root of the two individual variances. This can be used to create a matrix of correlation between two points:</p>
<p>\[ q_{ij} = \frac{Cov(X_i, X_j)}{\sqrt{Var(X_i)Var(X_j)}} \]</p>
<p>This can be used to find conditional independence between the variables, using maximum log-likelihood analysis. </p>
<p>Regularisation, pushes some coordinates to 0 of the covariance matrix, allowing conditional independent variable to be considered with other variables.</p>
<p>Using all the information gathered on correlation and causality between variables, a gene regulation network can be created</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequence-matching"><a class="header" href="#sequence-matching">Sequence Matching</a></h1>
<p>Sequence matching is useful for:</p>
<ul>
<li>Finding similarity in Protein/DNA between related species </li>
<li>Transfer knowledge about known sequences to new sequences</li>
<li>Compare sequences with other species, although need to know which part of the sequence to match</li>
</ul>
<p>To reassemble sequences after sequencing, we need to find best matches at both the DNA and Protein levels</p>
<p>Mutations in proteins are more likely to have adverse effects than DNA, meaning they are more highly conserved. This means they are unlikely to change between generations, species, or even kingdoms. DNA mutation are les conserved as the often have no effect</p>
<p>Some coding sequences are so important they are conserved in all living things, i.e the coding for proteins used in transcription and translation. All inherited from the universal common ancestor. </p>
<p>Some amino acids are more similar to each other, meaning they have a higher chance of being substituted with each other. </p>
<p>BLOSUM 50 is a data set of substitution rates, using known alignments it is calculated by:</p>
<ul>
<li>Eliminating sequences with higher than a given similarity</li>
<li>Calculating frequency of pairs of amino acids</li>
<li>Calculate the ratio of occurrence of each amino acid combination.</li>
<li>Calculate log odds of each pair, i.e. how often they occur as a pair compared to how often then would be expected if independent: \[ 2\log_2(\frac{P_{ab}}{P_aP_b}) \]</li>
</ul>
<p>The BLOSUM 50 table can be used to look up the probability of the \(i\)th amino mutating to the \(j\)th amino acid</p>
<p>It is also a possibility that there could be a gap, i.e. a insertion or deletion. </p>
<p>As there is an infeasible number of possible inexact matches to check, so we use dynamic programming to build up an optimal set of partial solutions until we have a solution for the entire string. Each step builds upon the previous optimal solutions. Dynamic programming reduces the complexity from O(\(2^n\)) to O(\(n^2\))</p>
<h3 id="exact-methods"><a class="header" href="#exact-methods">Exact Methods</a></h3>
<p><strong>Needleman-Wunsch</strong> is an algorithm for computing global alignments between two strings. </p>
<ul>
<li>BLOSUM 50 is used for substitution costs, a to b</li>
<li>Linear cost (d = -8) is used for insertion and deletion</li>
</ul>
<p>We use the costs to build up a cost matrix \(F\) where each cell (n, m) gives the best alignment for strings \(a_{0:n} \) and \(b_{0:m}\). The top left is the start, which is filled with 0. This is done recursively with the equation: \[ F_{i, j} = \max \begin{cases} F_{i-1, j-1} + S_{a_i, b_j} \\ F_{i-1, j} + d \\ F_{i, j-1} + d \end{cases}\]</p>
<p>Corresponding to substitution, a gap, b gap respectively. </p>
<p>At each cell a pointer is kept to indicate which previous state the cell came from (i.e. the action used). After the table is filled we start at the bottom right and follow the back pointers to find the best alignment. </p>
<p>NW global matching has a time complexity of O(A size x B size) which is not an issue. The main problem is it has the same space complexity making it a problem for long sequences. </p>
<p><em>Hirschberg</em> is another global matching algorithm which recursively splits up the string making it have linear space complexity. Is still quadratic in time, but in practise tends to take twice as long as NW</p>
<p><strong>Smith-Waterman</strong> is an algorithm for local matching, finds the best aligned substring within two strings. </p>
<p>It is very similar to NW, with the added option of ignoring an operation for a cost of 0: \[ F_{i, j} = \max \begin{cases} 0 \\ F_{i-1, j-1} + S_{a_i, b_j} \\ F_{i-1, j} + d \\ F_{i, j-1} + d \end{cases} \]</p>
<p>The table is filled in the same way, using back pointers to the previous cell if the operation wasn't ignore. </p>
<p>Once it is filled, we start from the highest value in the table rather than the last value, and follow the points until we reach a 0 to find the local alignment. </p>
<p>To deal with multiple best matches, caused by repeats of one region within another, smith-waterman can be adapted. </p>
<p>Both NW and SW use linear gap costs, i.e. each site is independent. This is problematic as in reality mutations can occur in sequences.</p>
<p>To fix this we add an affine (linear, i.e. y = mx +c) gap cost function evaluated over all previous possible gap sizes: \( \gamma(g) = -d - e(g-1) \). d=12 and e=3 gives a good model which penalises all gaps but larger slightly more punished. </p>
<p>To implement this however, three matrices are needed. It is easier to visualise these using finite state automata, where the states are the matrices and arcs are the operation costs</p>
<h3 id="approximate-methods"><a class="header" href="#approximate-methods">Approximate Methods</a></h3>
<p>Proteins we have chains of 100s of amino acids, meaning the quadratic time of these algorithms is possible, but slow.</p>
<p>DNA however is 10^5 to 10^11 bases long, meaning quadratic time is not feasible. To achieve this we need approximate methods</p>
<p><strong>FASTA</strong> is a heuristic method that finds candidate subsequences for alignments. Smith-waterman is then used of the subsequences. It has however been superseded by BLASTA</p>
<p><strong>BLASTA</strong> is another heuristic method which:</p>
<ul>
<li>filters out low complexity regions or repeated sequences</li>
<li>make k-letter exact matches word list from the sequence</li>
<li>evaluates of <em>significant</em> matches</li>
<li>Combines high scoring matches to find gapped regions.</li>
<li>Finishes off with Smith Waterman</li>
</ul>
<p>The find the significance of a match, i.e. the probability of a match given sequences a and b we can use the logistic equation on the probabilities: </p>
<p>\[ P(M|a, b) = \sigma (\log\frac{P(a, b|M)}{P(a, b|R)} + \log\frac{P(M)}{P(R)}) \]</p>
<p>Another approach is finding the likelihood of a particular score being random rather than a match is to use <em>extreme value distributions</em>.</p>
<p><img src="Y3/3212/the-little-book-of-computational-biology/src/images/EVD.png" alt="EVD" /></p>
<p>Where we sample multiple distributions, and take the most extreme value of each distribution to create an extreme value distribution.</p>
<p>EVDs are more accurate the longer the string.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hidden-markov-models"><a class="header" href="#hidden-markov-models">Hidden Markov Models</a></h1>
<p>In machine learning we often need to determine the probability of target \(y\) given the features \(x\), i.e. P(y|x). This is known as discrimination</p>
<p>To model a sequence of states, the probability of the current state depends on all previous states. However, we can simplify this by the <strong>Markov Assumption</strong> which states that the current state only depends on the pervious state. This is overly simply for biological sequences</p>
<p>We can extend this by creating a finite automata, at each time step:</p>
<ul>
<li>Model emits a an output (e.g. base, codon..)</li>
<li>Model transmits to new states</li>
</ul>
<p>Each state has a certain probability of emitting different outputs, as well as certain probabilities of moving to new states, thus the next state depends only on the current. To use the model we only ever see the emissions, not the states, thus it is given a name: <strong>Hidden Markov Model</strong> </p>
<p><img src="Y3/3212/the-little-book-of-computational-biology/src/images/dice-HMM.png" alt="Dice HMM" /></p>
<p>Consider the HMM for a a pair of dice, one fair and one loaded. The arcs are the transmission probabilities between states and the nodes contain the emission probabilities of each state.</p>
<p>The parameters are given:</p>
<ul>
<li>Emission in state i: \( e_i(l_n) = P(l_n|q_t = i) \)</li>
<li>Transition in state i to j: \( q_{ij} = P(q_t = j|q_{t-1} = i) \)</li>
</ul>
<p>Where:</p>
<ul>
<li>\(l_n \) is a letter from an alphabet</li>
<li>\( q_t \) is the state at time t</li>
</ul>
<p>To use a HMM, given an observed sequence of emissions we want to find the most probable sequence of states that generated them. </p>
<p>To do this the <strong>Viterbi</strong> algorithm is used, which is an instance of dynamic programming. </p>
<p>Where \( v_i(t) \) is the probability of being in state i at time t and \( v_0(0) = 1 \) and all others at time 0 are 0, indicating the start state.  Viterbi follows:</p>
<ul>
<li>For each time step:
<ul>
<li>For all states:
<ul>
<li>compute the probability of each state at this time step by multiplying the observed emission probability by the highest previous state and transmission to current state value.</li>
<li>This is: \( \log v_i(t) = \log e_i(l_t) + \max_j(\log v_j(t-1) + \log a_{ij}) \)</li>
</ul>
</li>
<li>Keep a pointer to the previous most likely state: \( ptr_t(i) = \underset{j}{argmax}(\log v_j(t-1) + \log a_{ij} ) \)</li>
</ul>
</li>
</ul>
<p>Note: Log probabilities are used to prevent numerical underflow</p>
<p>Following the pointers backwards allows us find the most likely sequence of states which generated the observed sequence.</p>
<p>However, this can be inaccurate. It is better to ask what the probability of being in a certain state at time t given sequence x. i.e. \( P(q_t = k | x) \)</p>
<p>To do this we use Viterbi but replace the max with sum and changing the backwards section. This allows us to calculate the probability of a sequence, summed over all the possible paths. We can then plot the probabilities of all states at time t being a certain state. </p>
<p>In biology, HMMs are used to inform unseen sequences based on the relative probabilities of each residue in a sequence. E.g. if a protein is a kinase protein, secondary structure probabilities, sections of genes.</p>
<h4 id="training"><a class="header" href="#training">Training</a></h4>
<p>However this relies on us knowing the probabilities within biology, which in reality we don't. To do this we need to train the model on known sequence and state paths. </p>
<p>Given a sequence and state path we can count:</p>
<ul>
<li>The number of transitions between states: \( A_{ij} \)</li>
<li>The count of emissions in each state: \( E_i(l) \)</li>
</ul>
<p>Using these we can estimate the parameter probabilities in HMMs: \[ e_i(l) = \frac{E_i(l)}{\sum_{l\in A}E_i(l)};\ a_{ij} = \frac{A_{ij}}{\sum_{k \in Q} A_{ik}} \]</p>
<p>We may need to add pseudo-counts (i.e. Add-k Smoothing?) to allow transitions we don't see much in the training data. </p>
<p>To train the model:</p>
<ul>
<li>Make initial guess at transition and emission probabilities</li>
<li>repeat, until good estimation:
<ul>
<li>Calculate posterior probabilities - Expectation</li>
<li>Calculate new transition and emission probabilities given previous - Maximisation</li>
</ul>
</li>
</ul>
<h4 id="designing"><a class="header" href="#designing">Designing</a></h4>
<p>Designing the structure of a HMM (number of states, allowed transitions, order) is challenging as:</p>
<ul>
<li>Too few states: underfitting, fail to model significant differences</li>
<li>Too many states: overfitting and poor generalisation, model noise</li>
<li>Too many transitions can overfit, should represent real structure</li>
<li>Markov property can impose too short range of a structure, can extend to higher-order dependencies </li>
</ul>
<p>GENESCAN is a fifth-order Markov model which was used to find genes. By looking for areas with a high &quot;CG&quot; pair content</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="neural-applications"><a class="header" href="#neural-applications">Neural Applications</a></h1>
<p>HMMs can only do so much. Predicting secondary protein structure is difficult as the data is non-local, which HMMs don't deal well with.</p>
<p>Neural Networks can be used.</p>
<p>NETtalk is a MLP with windowed input that is used to predict protein structure, it uses:</p>
<ul>
<li>Mean squared erorr as a loss function</li>
<li>Windowed input (target and ±n context words). This allows input of an arbitrary length sequence</li>
<li>One hot encoding for representation</li>
</ul>
<p>Profiling homologous proteins (same tertiary structure and approximately same secondary structure). Allows relationships between different proteins to be expressed in the coding. +5% accuracy gains</p>
<p>One hot encoding is used for amino acids as using a scalar number would imply that amino acid 1 and 2 are more related to 1 and 20. Amino acids are not related so one hot encoding is used. </p>
<p>The distribution of secondary structure types is not balanced, Using balanced training data will reduce the overall performance slightly. </p>
<p>Using structural context, e.g. alpha helices are ~ 10 amino acids long and beta sheets are ~ 6 long, can be used to check valid predictions</p>
<p><strong>PSI BLAST</strong> is a MLP based local alignment searcher. This can be used with <strong>PSI PRED</strong> to predict secondary structures ~77%</p>
<p>Cross entropy loss + softmax is better than MLE for multi-class classification as it deals better with minority classes:</p>
<ul>
<li>Softmax: \( P(i) = \frac{e^{x_i}}{\sum_j e^{x_j}} \)</li>
<li>Cross entropy Loss:  \( H(y, q) = - \sum^N_{i=1} y_i \log q_i \)</li>
</ul>
<h4 id="deep-learning"><a class="header" href="#deep-learning">Deep learning</a></h4>
<p>To get better results we need deep neural nets (DNNs). Where are neural networks with 3 or more layers. </p>
<p><strong>LSTMs</strong> are recurrent memory cells with allow networks to learn long range dependencies. This makes them good at language modelling, protein homology detection.</p>
<p><strong>Deep belief nets</strong> learn a layer at a time, which is then fixed before learning the next layer. This has applications for estimating protein model quality and stability predictions. </p>
<p><strong>Convolutional neural nets</strong> are inspired by the visual cortex. Uses filters and weight sharing. This is mainly used in computer vision which has many uses is biology such as classifying medical imagery and gene expressions</p>
<p><strong>Auto encoders</strong> are used to encode information, such as word or DNA to vectors by learning a vector embedding for them. These representations can carry semantic meaning unlike other encoding forms like one hot encoding</p>
<p><strong>Attention</strong> and <strong>Transformers</strong> are a modern architecture of DNNs where the idea is that some words are more important than others. Skip connections are also used to preserve information</p>
<p>CASP is a competition ran twice yearly that tasks people to create the best model for predicting protein structures</p>
<p><strong>Residual Nets</strong> such as AlphaFold are the latest in this field and variations have one every year since 2017</p>
<p>AlphaFold is good because:</p>
<ul>
<li>input:
<ul>
<li>Multiple sequence alignment</li>
<li>pairwise templates</li>
</ul>
</li>
<li>Embeddings combine:
<ul>
<li>sequence alignments</li>
<li>coevolutionary features</li>
<li>template angles</li>
<li>template pairwise features</li>
</ul>
</li>
<li>Evoformer:
<ul>
<li>treats structure as spacial graph</li>
<li>Builds graph using embeddings</li>
<li>combines pairwise and msa embeddings</li>
<li>48 blocks</li>
<li>attention</li>
</ul>
</li>
<li>structure:
<ul>
<li>uses attention</li>
</ul>
</li>
</ul>
<ul>
<li>Recycling</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="population-dynamics"><a class="header" href="#population-dynamics">Population Dynamics</a></h1>
<p>Population dynamics looks at how population levels vary of time given certain factors. Formed by combining biostatistics and Mendelian inheritance</p>
<p>Prior to Mendel it was thought characteristic were blended, <strong>Mendelian Inheritance</strong> is the idea that the parents characteristics are independent and children independent parts of both not a mix. </p>
<p>Biostatistics cover the statistics population dynamics:</p>
<ul>
<li>Wright found:
<ul>
<li>Inbreeding gave more variation</li>
<li>Small isolated populations led to more variation towards a local optima</li>
</ul>
</li>
<li>Fisher found: 
<ul>
<li>Large populations don't need to worry about local optima</li>
<li>Sufficiently large populations will always move &quot;uphill&quot;</li>
</ul>
</li>
<li>Haldne found:
<ul>
<li>certain features are inherited together (e.g. genetic linkage)</li>
<li>Provided evidence for inheritance via chromosomes</li>
</ul>
</li>
</ul>
<p>Modern synthesis of evolution brings together:</p>
<ul>
<li>Natural selection</li>
<li>Population genetics</li>
<li>Medelian genetics</li>
</ul>
<p>We know that:</p>
<ul>
<li>Genes can mutate</li>
<li>Alleles are exchanged during sexual reproduction</li>
<li>Evolutionary fitness measures the long term number of offspring</li>
<li>Epistasis, genes interact</li>
<li>Linkage disequilibrium</li>
<li>Generations overlap</li>
</ul>
<h3 id="fisher-wright-model"><a class="header" href="#fisher-wright-model">Fisher Wright model</a></h3>
<p>The FW model looks at how a single mutation can take over in a population.</p>
<p>This model assumes:</p>
<ul>
<li>genes can be changed from one allele to another via mutation</li>
<li>Alleles are exchanged during sexual reproduction</li>
<li>Fitness is a measure of the expected number of offspring</li>
<li>no epistasis</li>
<li>linkage equilibrium</li>
<li>generations do not overlap</li>
</ul>
<p>To make models with FW we make further assumptions:</p>
<ul>
<li>No gender</li>
<li>Haploid (one copy of genes)</li>
<li>Two states normal (P) and mutant (Q)</li>
<li>Q has selective advantage of 1+s</li>
<li>P mutates to Q at rate m</li>
<li>Q mutates to P at rate n</li>
<li>constant population size (N) (for infinite populations we can approximate using differential equation)</li>
</ul>
<p>Each generation follows:</p>
<ul>
<li>individuals produce seeds</li>
<li>seeds mutate according to m and n</li>
<li>sample N of the seeds</li>
</ul>
<p>In reality we don't use exact numbers for seeds, only the proportion of mutants compared to normal, the model:</p>
<ul>
<li>Find the proportion of mutants after seeding: \( p_s = \frac{(1+s)x}{N+sx} \) where x is the number of mutants in this generation</li>
<li>Mutate the seeds and find the new proportion of mutants: \( p_{sm} = (1-n)p_s + m(1 - p_s) \)</li>
<li>Sample N individuals, using a binomial with the proportion of mutants: \( P(x(t+1) = x) = \binom{N}{x} p^x_{sm}(1-p_{sm})^{N-x} \)</li>
</ul>
<p>If we presume that the population is infinite we can just use proportions instead of numbers: \[ p_x(t+1) = \frac{(1-n)(1+s)p_x(t) + m(1 - p_x(t))}{1 + sp_x(t)} \]</p>
<p>Which can be approximated by a differential equation if the effects of selection and mutation are small: \[ \frac{dp_x}{dt} \approx p_x(t+1) - p_x(t) \]</p>
<p>The problem with this is that if mutants are fitter, they will grow exponentially at the start. ODEs have much more rapid take over times than finite population models if low mutation rates</p>
<p>Finite models are stochastic, where as infinite populations are deterministic.</p>
<h3 id="markov-models"><a class="header" href="#markov-models">Markov Models</a></h3>
<p>Evolving populations can be modelled using a Markov chains. </p>
<p>To do this we define:</p>
<ul>
<li>A transition matrix \( W_{x', x} \) where each cell represents the probability from x to x' mutants.</li>
<li>The probability of x mutants are updated with \( p(t+1) = Wp(t) \)</li>
<li>The start prob for no mutants:  \( p(t=0) = [1, 0, 0, ...] \)</li>
</ul>
<p>Thus, \(p(t) = W^tp(0) \)</p>
<p>This model creates a probability distribution over the number of mutants for each time step. </p>
<p>The transition matrix is given: </p>
<p>\[ W_{x', x} = \binom{N}{x'} p_sm(x)^{x'}(1-p_{sm}(x)^{N-x'}) \]</p>
<p>Where:</p>
<p>\[ p_{sm}(x) = \frac{(1-n)(1+s)x + m(N-x)}{N+sx} \]</p>
<p>Markov models provide an exact analysis of population dynamics. However, as the  matrix is the size of the states + 1 squared, this model is infeasible for large populations.</p>
<h3 id="stochastic-differential-equations"><a class="header" href="#stochastic-differential-equations">Stochastic Differential Equations</a></h3>
<p>To model the randomness inherent in population dynamics, stochastic differential equations are used. These work best with weak selection and small mutation rates</p>
<p>Presume a random walk (±1). The expectation of distance travelled is zero, as well as the expectation of number of steps in total. However, the expectation of the squared distance is somehow equal √N </p>
<p>With random time steps dt and for a walk with distance x, the change is distance is measured:</p>
<p>\[ dx = adt + bdW(t) \]</p>
<p>where:</p>
<ul>
<li>a is the drift, i.e the expected change</li>
<li>b is the variance, due to random processes</li>
<li>W(t) is a random process drawing from a normal distribution with mean 0 and variance dt: i.e.  N(0, dt)</li>
</ul>
<p>This is closely related to a Maxwell-Boltzmann distribution.</p>
<p>Applying this to evolution:</p>
<ul>
<li>Time steps are generations</li>
<li>Distance is the number of mutants in the population</li>
<li>dx is the change in mutants in each time step</li>
</ul>
<p>We get:</p>
<p>\[ X(t+dt) = X(t) + a(X(t))dt + b(X(t))dW(t) \]</p>
<p>Where:</p>
<ul>
<li>Expected change / drift: a(X(t)) = (p_{sm}(X(t)) - X(t))dt</li>
<li>Variance: b(X(t)) = \frac{p_{sm}(X(t))(1-p_{sm}(X(t)))}{N}dt</li>
</ul>
<p>If s, m, and n are small then \( p_{sm} \approx X(t) \) and can be substituted in variance.</p>
<p>We get a stochastic differential equation or SDE:</p>
<p>\[ dX(t) = a(X(t))dt + b(X(t))dW(t) \]</p>
<p>This is known as an Itô process which can be solved. There is no closed from solution for the differential of W(t) as this will also be stochastic. We can however solve the probability distribution: \( f(x, t)dx = P(x \le X(t) \lt x + dx) \)</p>
<p>The solution to this is given by the <strong>Fokker-Planck</strong> equation (i.e. Forward Kolmogorov):</p>
<p>\[ \frac{\partial f(x, t)}{\partial t} = -\frac{a(x)\partial f(x, t)}{\partial x} + \frac{1}{2} \frac{\partial^2(b^2(x)f(x, t))}{\partial x^2} \]</p>
<p>However diffusion doesn't go backwards so we need to the Backward Kolmogorov:</p>
<p>\[ \frac{\partial f(x, -t)}{\partial t} = -a(x)\frac{\partial f(x, -t)}{\partial x} + \frac{1}{2} b^2(x)\frac{\partial^2(f(x, -t))}{\partial x^2} \]</p>
<p>This can be used to work out how long it might take to get to an absorbing state and how likely this state may be</p>
<p>Fokker-Planck shifts the SDE into a PDE. This is hard to solve directly but can use numerical methods. This is almost identical to Markov Chain analysis and can scale well to large numbers</p>
<h3 id="steady-state-distribution"><a class="header" href="#steady-state-distribution">Steady State Distribution</a></h3>
<p>Solving the PDE is hard in the previous model. We can approximate this by solving for when it equals 0, i.e. when the distribution stops changing at t tends to ∞. This can be done as solving for t tends to ∞ does not depend on t. </p>
<p>It is solved using the equation:</p>
<p>\[ f_{eq}(x) = \frac{x^{2Nm-1}(1-x)^{Nn-1}e^{2Nsx}}{\text{Betaln}(2Nm, 2Nn)\text{Hyp1f1}(2Nm; 2N(m + n); 2Nsx)} \]</p>
<p>This is a valid approximation as evolution is slow, which means the steady state is often seen. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evolutionary-trees"><a class="header" href="#evolutionary-trees">Evolutionary Trees</a></h1>
<p>TBC: </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boolean-networks"><a class="header" href="#boolean-networks">Boolean Networks</a></h1>
<p>TBC</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="epigenetics"><a class="header" href="#epigenetics">Epigenetics</a></h1>
<p>Epigenetics is the modification of the gene expression though the modification of the histone proteins and the methylation of some cytosine residues in the genomic DNA. Simply put these factors can provide an on/off switch for transcription, impacting the dynamics of the transcription network.</p>
<p>Epigenetics process are considered key determinants that lead to different diseases. </p>
<p>Histone acetylation can suppress the gene. DNA methylation of cytosine (C) can suppress or activate the gene</p>
<p>Stem cells have more methylated CpG islands than somatic cells, thus  it is an important mechanism for specialisation of stem cells. </p>
<p>Epigenetics can be seen as another component in a complex boolean network</p>
<p>Cytosine methylation is inherited, thus defining some inherited diseases. This has led it to be considered as a fifth nucleic base in the genome</p>
<h3 id="biological-oscillators"><a class="header" href="#biological-oscillators">Biological Oscillators</a></h3>
<p>Do we need this??</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
